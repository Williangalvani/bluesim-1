[gd_resource type="ShaderMaterial" load_steps=4 format=3 uid="uid://bqefm2sjfvjij"]

[sub_resource type="Shader" id="1"]
code = "shader_type canvas_item;

uniform sampler2D depth_map;
uniform sampler2D noise: repeat_enable;
uniform sampler2D previous_image;
uniform float camera_angle;
uniform float size;
uniform float fov;

float get_intensity_at_distance_angle(vec2 _UV, float distance, float angle) {
	float x = angle*size;
	if (x>size || x < 0.0) {
		return -1.0;
	}
	float y = distance;
	float accum = 0.0;
	//iterate over each distance in the plot
	for (float i = 0.0; i<size; i++) {
		float pixel = texelFetch(depth_map, ivec2(int(x), int(i)), 0).r;
		// if we have a pixel with the color intensity for that distance, add it
		if (abs(pixel - y) < 0.02) {
			accum += abs(pixel - y);	
		}
	}
	return accum + texture(noise, (_UV)+vec2(TIME*0.1)).r*0.25;
}

vec3 gradient(float value) {
    // Define colors in an array
    vec3 colors[5] = vec3[](
        vec3(5.0/255.0, 34.0/255.0, 95.0/255.0),    // color0
        vec3(106.0/255.0, 168.0/255.0, 79.0/255.0), // color1
        vec3(255.0/255.0, 255.0/255.0, 0.0/255.0),  // color2
        vec3(127.0/255.0, 96.0/255.0, 0.0/255.0),   // color3
        vec3(160.0/255.0, 15.0/255.0, 8.0/255.0)    // color4
    );

    // Map value from [0, 1] to [0, 4) for indexing colors
    value = value * 4.0;
    int index = int(value);
    index = clamp(index, 0, 3); // Ensure index is within bounds

    // Normalize value to [0, 1] for interpolation
    value = fract(value);

    // Linearly interpolate between the two colors in the segment
    return mix(colors[index], colors[index + 1], value);
}

void fragment() {
    //ALBEDO = vec3(float(get_array_value(ivec2(vec2(100.0, 360.0) * UV))));
    vec2 sizeOverRadius = vec2(2.0, 2.0);
    float polarFactor = 1.0;

    //Move position to the center
    vec2 relPos = UV - vec2(0.5 ,0.5);

    //Adjust for screen ratio
    relPos *= sizeOverRadius;

    //Normalised polar coordinates.
    //y: radius from center
    //x: angle
    vec2 polar;

    polar.y = sqrt(relPos.x * relPos.x + relPos.y * relPos.y);
	
    //Any radius over 1 would go beyond the source texture size, this simply outputs black for those fragments


    polar.x = camera_angle + atan(relPos.y, relPos.x)+(fov/180.0*PI);

    //Fix glsl origin with src data
    polar.x += 3.1415/2.0;

    //Normalise from angle to 0-1 range
    polar.x /= 3.1415*2.0;
    polar.x = mod(polar.x, 1.0);


    //This inverts the radius variable depending on the polarFactor
    //polar.y = polar.y * polarFactor + (1.0 - polar.y) * (1.0 - polarFactor);

    //Sample at positions with a slight offset
    //vec4 one = texelFetch(depth_map,   ivec2 (int(polar.y*75.0),   int((1.0 - polar.x  - xOffset)*360.0) ), 0);
    //vec4 two = texelFetch(depth_map,   ivec2 (int(polar.y*75.0),   int((1.0 - polar.x)*360.0) ),            0);
    //vec4 three = texelFetch(depth_map, ivec2 (int(polar.y*75.0),   int((1.0 - polar.x + xOffset)*360.0) ),  0);
    float sample = 1.0*polar.y;
	float actual_angle = polar.x*(360.0/fov);
	sample = get_intensity_at_distance_angle(UV,polar.y,polar.x + actual_angle);
	COLOR.rb = vec2(0.0,0.0);
	if(sample < 0.0) {
		COLOR.rgb = texture(previous_image, UV).rgb;
	} else {
		COLOR.g = max(sample, 0) + smoothstep(0.2,0.0,polar.y);
		COLOR.rgb = gradient(COLOR.g);
	}
    COLOR.a = 1.0 - smoothstep(0.9, 1.0 ,polar.y);

	//COLOR.g = get_intensity_at_distance_angle(UV, UV.x, UV.y);
	
}"

[sub_resource type="FastNoiseLite" id="FastNoiseLite_laq5j"]

[sub_resource type="NoiseTexture2D" id="NoiseTexture2D_pk5r7"]
seamless = true
noise = SubResource("FastNoiseLite_laq5j")

[resource]
shader = SubResource("1")
shader_parameter/camera_angle = 90.0
shader_parameter/size = 256.0
shader_parameter/fov = 25.0
shader_parameter/noise = SubResource("NoiseTexture2D_pk5r7")
